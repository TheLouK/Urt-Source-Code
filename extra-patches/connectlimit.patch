Index: code/server/sv_client.c
===================================================================
--- code/server/sv_client.c	(revision 949)
+++ code/server/sv_client.c	(working copy)
@@ -380,6 +380,31 @@
 			NET_OutOfBandPrint(NS_SERVER, from, "print\nNo or bad challenge for address.\n");
 			return;
 		}
+		if (sv_limitConnectPacketsPerIP->integer > 0) {
+			// We limit 4 connect packets from one IP address in the past 6 seconds.
+			receipt_t *connect = &svs.connects[0];
+			int oldest = 0;
+			int oldestTime = 0x7fffffff;
+			int connectPacks = 1; // Count this packet as one.
+			for (i = 0; i < MAX_CONNECTS; i++, connect++) {
+				if (NET_CompareBaseAdr(from, connect->adr) &&
+						connect->time + 6000 > svs.time) {
+					connectPacks++;
+				}
+				if (connect->time < oldestTime) {
+					oldestTime = connect->time;
+					oldest = i;
+				}
+			}
+			if (connectPacks > 4) {
+				Com_DPrintf("Ignoring connect packet from %s, seems to be spamming\n",
+						NET_AdrToStringwPort(from));
+				return;
+			}
+			connect = &svs.connects[oldest];
+			connect->adr = from;
+			connect->time = svs.time;
+		}
 	}
 
 	// At this point we have verified that the "from" address has not been spoofed.
@@ -489,14 +514,26 @@
 		startIndex = sv_privateClients->integer;
 	}
 
+	qboolean checkMaxClientsPerIP = ((sv_maxClientsPerIP->integer > 0) && (!Sys_IsLANAddress(from)));
+	int clientsThisIP = 0;
 	newcl = NULL;
 	for ( i = startIndex; i < sv_maxclients->integer ; i++ ) {
 		loopcl = &svs.clients[i];
 		if (loopcl->state == CS_FREE) {
-			newcl = loopcl;
-			break;
+			if (newcl == NULL) { newcl = loopcl; }
 		}
+		// In this "else" statement, the client is _not_ CS_FREE.  Even if it's CS_ZOMBIE, count the
+		// the client if the IP address matches.
+		else if (checkMaxClientsPerIP && NET_CompareBaseAdr(from, loopcl->netchan.remoteAddress)) {
+			clientsThisIP++;
+		}
 	}
+	if (newcl != NULL && // If server is full, give them the "server full" message below.
+			checkMaxClientsPerIP && clientsThisIP >= sv_maxClientsPerIP->integer) {
+		NET_OutOfBandPrint(NS_SERVER, from, "print\nCurrently too many clients from your IP address.\n");
+		Com_DPrintf("Recected a connect, too many clients from IP address %s\n", NET_AdrToString(from));
+		return;
+	}
 
 	if ( !newcl ) {
 		if ( NET_IsLocalAddress( from ) ) {
Index: code/server/server.h
===================================================================
--- code/server/server.h	(revision 949)
+++ code/server/server.h	(working copy)
@@ -247,6 +247,8 @@
 
 #define MAX_INFO_FLOOD_BANS	36
 
+#define MAX_CONNECTS	256
+
 ///////////////////////////////////////////////////////////
 // separator for connectlimit.patch and reconnectwait.patch
 ///////////////////////////////////////////////////////////
@@ -270,6 +272,7 @@
 	challenge_t	challenges[MAX_CHALLENGES];	// to prevent invalid IPs from connecting
 	receipt_t	infoReceipts[MAX_INFO_RECEIPTS];	// prevent getinfo/getstatus flood and DRDoS attacks
 	floodBan_t	infoFloodBans[MAX_INFO_FLOOD_BANS];
+	receipt_t	connects[MAX_CONNECTS];
 	///////////////////////////////////////////////////////////
 	// separator for connectlimit.patch and reconnectwait.patch
 	///////////////////////////////////////////////////////////
@@ -333,6 +336,9 @@
 
 extern	cvar_t	*sv_userinfoFloodProtect;
 
+extern	cvar_t	*sv_limitConnectPacketsPerIP;
+extern	cvar_t	*sv_maxClientsPerIP;
+
 extern	serverBan_t serverBans[SERVER_MAXBANS];
 extern	int serverBansCount;
 
Index: code/server/sv_init.c
===================================================================
--- code/server/sv_init.c	(revision 949)
+++ code/server/sv_init.c	(working copy)
@@ -691,6 +691,9 @@
 
 	sv_userinfoFloodProtect = Cvar_Get ("sv_userinfoFloodProtect", "1", CVAR_ARCHIVE | CVAR_SERVERINFO );
 
+	sv_limitConnectPacketsPerIP = Cvar_Get ("sv_limitConnectPacketsPerIP", "0", CVAR_ARCHIVE );
+	sv_maxClientsPerIP = Cvar_Get ("sv_maxClientsPerIP", "0", CVAR_ARCHIVE );
+
 	// initialize bot cvars so they are listed and can be set before loading the botlib
 	SV_BotInitCvars();
 
Index: code/server/sv_main.c
===================================================================
--- code/server/sv_main.c	(revision 949)
+++ code/server/sv_main.c	(working copy)
@@ -61,6 +61,9 @@
 cvar_t	*sv_userinfoFloodProtect;	// whether to limit two client userinfo changes per 2000 milliseconds,
 					// default 1 (limit)
 
+cvar_t	*sv_limitConnectPacketsPerIP;
+cvar_t	*sv_maxClientsPerIP;
+
 serverBan_t serverBans[SERVER_MAXBANS];
 int serverBansCount = 0;
 
