Index: code/server/sv_client.c
===================================================================
--- code/server/sv_client.c	(revision 815)
+++ code/server/sv_client.c	(working copy)
@@ -1562,6 +1562,284 @@
 #endif
 
 
+/*
+==================
+SV_DisplayGotoHelp_f
+==================
+*/
+static void SV_DisplayGotoHelp_f(client_t *cl) {
+	SV_SendServerCommand(cl, "print \"The following are commands for save/load position and goto:\n\"");
+	SV_SendServerCommand(cl, "print \"    \\helpgoto       - show list of commands\n\"");
+	SV_SendServerCommand(cl, "print \"    \\saveposition   - save current position\n\"");
+	SV_SendServerCommand(cl, "print \"    \\loadposition   - load saved position%s\n\"",
+			(sv_allowLoadPosition->integer > 0) ? "" : " (currently disabled)");
+	SV_SendServerCommand(cl, "print \"    \\allowgoto 1    - allow others to goto where you are\n\"");
+	SV_SendServerCommand(cl, "print \"    \\allowgoto 0    - disallow others to goto where you are\n\"");
+	SV_SendServerCommand(cl, "print \"    \\goto <client>  - goto another player%s\n\"",
+			(sv_allowGoto->integer > 0) ? "" : " (currently disabled)");
+}
+
+
+/*
+==================
+SV_SavePosition_f
+==================
+*/
+static void SV_SavePosition_f(client_t *cl) {
+	int		clId;
+	playerState_t	*myState;
+
+	clId = cl - svs.clients;
+	if (TEAM_SPECTATOR == atoi(Info_ValueForKey(sv.configstrings[548 + clId], "t"))) {
+		SV_SendServerCommand(cl, "print \"You cannot be in spectator mode when saving your position.\n\"");
+		return;
+	}
+	myState = SV_GameClientNum(clId);
+	if (myState->pm_type != PM_NORMAL) {
+		SV_SendServerCommand(cl, "print \"You must be alive and in-game when saving your position.\n\"");
+		return;
+	}
+	if (Cmd_Argc() > 1) {
+		SV_SendServerCommand(cl, "print \"Too many arguments to saveposition command, none expected.\n\"");
+		return;
+	}
+	if (myState->groundEntityNum != ENTITYNUM_WORLD) {
+		SV_SendServerCommand(cl, "print \"You must be standing on solid ground when saving your position.\n\"");
+		return;
+	}
+	if (myState->velocity[0] != 0 || myState->velocity[1] != 0 || myState->velocity[2] != 0) {
+		SV_SendServerCommand(cl, "print \"You must be standing still when saving your position.\n\"");
+		return;
+	}
+	if (myState->pm_flags & PMF_DUCKED) {
+		SV_SendServerCommand(cl, "print \"You cannot be crouched when saving your position.\n\"");
+		return;
+	}
+	VectorCopy(myState->origin, cl->savedPosition);
+	cl->positionIsSaved = qtrue;
+	SV_SendServerCommand(cl, "print \"Your position has been temporarily saved.\n\"");
+}
+
+
+/*
+==================
+SV_LoadPosition_f
+==================
+*/
+static void SV_LoadPosition_f(client_t *cl) {
+	int		clId;
+	playerState_t	*myState;
+	int		loadPositionWaitTime, nextLoadPositionTime;
+
+	if (!(sv_allowLoadPosition->integer > 0)) {
+		SV_SendServerCommand(cl, "print \"Teleporting to saved position is disabled on server.\n\"");
+		return;
+	}
+	clId = cl - svs.clients;
+	if (TEAM_SPECTATOR == atoi(Info_ValueForKey(sv.configstrings[548 + clId], "t"))) {
+		SV_SendServerCommand(cl, "print \"You cannot be in spectator mode when loading saved position.\n\"");
+		return;
+	}
+	myState = SV_GameClientNum(clId);
+	if (myState->pm_type != PM_NORMAL) {
+		SV_SendServerCommand(cl, "print \"You must be alive and in-game when loading saved position.\n\"");
+		return;
+	}
+	if (Cmd_Argc() > 1) {
+		SV_SendServerCommand(cl, "print \"Too many arguments to loadposition command, none expected.\n\"");
+		return;
+	}
+	if (!(cl->positionIsSaved)) {
+		SV_SendServerCommand(cl, "print \"You must save your position first.\n\"");
+		return;
+	}
+	if (cl->lastLoadPositionTime > 0) { // Allow load position at "beginning of time" when svs.time is zero.
+		loadPositionWaitTime = sv_loadPositionWaitTime->integer;
+		if (loadPositionWaitTime < 0) { loadPositionWaitTime = 0; }
+		else if (loadPositionWaitTime > 3600) { loadPositionWaitTime = 3600; }
+		loadPositionWaitTime *= 1000;
+		nextLoadPositionTime = cl->lastLoadPositionTime + loadPositionWaitTime;
+		if (nextLoadPositionTime > svs.time) {
+			SV_SendServerCommand(cl, "print \"You must wait %i seconds before loading saved position again.\n\"",
+					((nextLoadPositionTime - svs.time) / 1000) + 1);
+			return;
+		}
+	}
+	if (myState->groundEntityNum != ENTITYNUM_WORLD) {
+		SV_SendServerCommand(cl, "print \"You must be standing on solid ground when loading saved position.\n\"");
+		return;
+	}
+	if (myState->velocity[0] != 0 || myState->velocity[1] != 0 || myState->velocity[2] != 0) {
+		SV_SendServerCommand(cl, "print \"You must be standing still when loading saved position.\n\"");
+		return;
+	}
+	VectorCopy(cl->savedPosition, myState->origin);
+	cl->lastLoadPositionTime = svs.time;
+	SV_SendServerCommand(cl, "print \"You have been teleported to your last saved position.\n\"");
+}
+
+
+/*
+==================
+SV_UserGetPlayerByHandle
+==================
+*/
+static client_t *SV_UserGetPlayerByHandle(char *s) {
+	client_t	*cl;
+	int		i, plid;
+	char		cleanName[64];
+
+	if (!com_sv_running->integer) { return NULL; }
+
+	for (i = 0; isdigit(s[i]); i++);
+	
+	if (!s[i]) {
+		plid = atoi(s);
+		if (plid >= 0 && plid < sv_maxclients->integer) {
+			cl = &svs.clients[plid];
+			if (cl->state) return cl;
+		}
+	}
+	for (i = 0, cl = svs.clients; i < sv_maxclients->integer; i++, cl++) {
+		if (!cl->state) { continue; }
+		if (!Q_stricmp(cl->name, s)) { return cl; }
+		Q_strncpyz(cleanName, cl->name, sizeof(cleanName));
+		Q_CleanStr(cleanName);
+		if (!Q_stricmp(cleanName, s)) { return cl; }
+	}
+	return NULL;
+}
+
+
+/*
+==================
+SV_UserAllowGoto_f
+==================
+*/
+static void SV_UserAllowGoto_f(client_t *cl) {
+	while (qtrue) { // Provides break structure.
+		if (Cmd_Argc() != 2) { break; }
+		if (strlen(Cmd_Argv(1)) != 1) { break; }
+		if (Cmd_Argv(1)[0] == '0') {
+			cl->allowGoto = qfalse;
+			SV_SendServerCommand(cl, "print \"Your personal allow goto deactivated.\n\"");
+			return;
+		}
+		if (Cmd_Argv(1)[0] == '1') {
+			cl->allowGoto = qtrue;
+			SV_SendServerCommand(cl, "print \"Your personal allow goto activated.\n\"");
+			return;
+		}
+		break;
+	}
+	SV_SendServerCommand(cl, "print \"Your personal allow goto currently turned %s.\n\"",
+				cl->allowGoto ? "on" : "off");
+	if (cl->allowGoto) {
+		SV_SendServerCommand(cl, "print \"    \\allowgoto 0   - turn it off\n\"");
+	}
+	else {
+		SV_SendServerCommand(cl, "print \"    \\allowgoto 1   - turn it on\n\"");
+	}
+}
+
+
+/*
+==================
+SV_Goto_f
+==================
+*/
+static void SV_Goto_f(client_t *cl) {
+	playerState_t	*myState;
+	int		myClId, targetClId;
+	int		gotoWaitTime, nextGotoTime;
+	client_t	*targetCl;
+	playerState_t	*targetState;
+
+	if (!(sv_allowGoto->integer > 0)) {
+		SV_SendServerCommand(cl, "print \"Goto is disabled on server.\n\"");
+		return;
+	}
+	myClId = cl - svs.clients;
+	if (TEAM_SPECTATOR == atoi(Info_ValueForKey(sv.configstrings[548 + myClId], "t"))) {
+		SV_SendServerCommand(cl, "print \"You cannot be in spectator mode when using goto.\n\"");
+		return;
+	}
+	myState = SV_GameClientNum(myClId);
+	if (myState->pm_type != PM_NORMAL) {
+		SV_SendServerCommand(cl, "print \"You must be alive and in-game when using goto.\n\"");
+		return;
+	}
+	if (Cmd_Argc() > 2) {
+		SV_SendServerCommand(cl, "print \"Too many arguments in goto command.\n\"");
+		return;
+	}
+	if (!(Cmd_Argv(1)[0])) {
+		SV_SendServerCommand(cl, "print \"You forgot to specify a goto target client.\n\"");
+		return;
+	}
+	if (cl->lastGotoTime > 0) { // Allow goto at "beginning of time" when svs.time is zero.
+		gotoWaitTime = sv_gotoWaitTime->integer;
+		if (gotoWaitTime < 0) { gotoWaitTime = 0; }
+		else if (gotoWaitTime > 3600) { gotoWaitTime = 3600; }
+		gotoWaitTime *= 1000;
+		nextGotoTime = cl->lastGotoTime + gotoWaitTime;
+		if (nextGotoTime > svs.time) {
+			SV_SendServerCommand(cl, "print \"You must wait %i seconds before using goto again.\n\"",
+					((nextGotoTime - svs.time) / 1000) + 1);
+			return;
+		}
+	}
+	if (myState->groundEntityNum != ENTITYNUM_WORLD) {
+		SV_SendServerCommand(cl, "print \"You must be standing on solid ground when using goto.\n\"");
+		return;
+	}
+	if (myState->velocity[0] != 0 || myState->velocity[1] != 0 || myState->velocity[2] != 0) {
+		SV_SendServerCommand(cl, "print \"You must be standing still when using goto.\n\"");
+		return;
+	}
+	targetCl = SV_UserGetPlayerByHandle(Cmd_Argv(1));
+	if (targetCl == NULL) {
+		SV_SendServerCommand(cl, "print \"You specified an invalid goto target client.\n\"");
+		return;
+	}
+	if (targetCl == cl) {
+		SV_SendServerCommand(cl, "print \"You cannot goto yourself!  D'oh!\n\"");
+		return;
+	}
+	if (!targetCl->allowGoto) {
+		SV_SendServerCommand(cl, "print \"That player does not allow goto.\n\"");
+		return;
+	}
+	targetClId = targetCl - svs.clients;
+	if (TEAM_SPECTATOR == atoi(Info_ValueForKey(sv.configstrings[548 + targetClId], "t"))) {
+		SV_SendServerCommand(cl, "print \"That player is currently in spectator mode.\n\"");
+		return;
+	}
+	targetState = SV_GameClientNum(targetCl - svs.clients);
+	if (targetState->pm_type != PM_NORMAL) {
+		SV_SendServerCommand(cl, "print \"That player isn't currently alive or isn't in-game.\n\"");
+		return;
+	}
+	if (targetState->groundEntityNum != ENTITYNUM_WORLD) {
+		SV_SendServerCommand(cl, "print \"That player is not currently standing on solid ground.\n\"");
+		return;
+	}
+	/*
+	if (targetState->velocity[0] != 0 || targetState->velocity[1] != 0 || targetState->velocity[2] != 0) {
+		SV_SendServerCommand(cl, "print \"That player isn't currently standing still.\n\"");
+		return;
+	}
+	*/
+	VectorCopy(targetState->origin, myState->origin);
+	if (targetState->pm_flags & PMF_DUCKED) {
+		myState->pm_flags |= PMF_DUCKED;
+	}
+	cl->lastGotoTime = svs.time;
+	SV_SendServerCommand(cl, "print \"Goto executed successfully.\n\"");
+	SV_SendServerCommand(targetCl, "print \"Player teleported to your location: %s\n\"", cl->name);
+}
+
+
 typedef struct {
 	char	*name;
 	void	(*func)( client_t *cl );
@@ -1584,6 +1862,15 @@
 	{NULL, NULL}
 };
 
+static ucmd_t ucmds_floodControl[] = {
+	{"helpgoto", SV_DisplayGotoHelp_f},
+	{"saveposition", SV_SavePosition_f},
+	{"loadposition", SV_LoadPosition_f},
+	{"allowgoto", SV_UserAllowGoto_f},
+	{"goto", SV_Goto_f},
+	{NULL, NULL}
+};
+
 /*
 ==================
 SV_ExecuteClientCommand
@@ -1639,6 +1926,16 @@
 		}
 	}
 
+	if (!bProcessed) {
+		for (u = ucmds_floodControl; u->name; u++) {
+			if (!Q_stricmp(Cmd_Argv(0), u->name)) {
+				if (clientOK) { u->func(cl); }
+				bProcessed = qtrue;
+				break;
+			}
+		}
+	}
+
 	if (clientOK) {
 		// pass unknown strings to the game
 		if (!u->name && sv.state == SS_GAME) {
Index: code/server/server.h
===================================================================
--- code/server/server.h	(revision 815)
+++ code/server/server.h	(working copy)
@@ -205,6 +205,11 @@
 	////////////////////////////////////////////
 	// separator for ip2loc.patch and goto.patch
 	////////////////////////////////////////////
+	vec3_t		savedPosition;
+	qboolean	positionIsSaved;
+	int		lastLoadPositionTime;
+	qboolean	allowGoto;
+	int		lastGotoTime;
 
 } client_t;
 
@@ -311,6 +316,11 @@
 
 extern	cvar_t	*sv_userinfoFloodProtect;
 
+extern	cvar_t	*sv_allowGoto;
+extern	cvar_t	*sv_gotoWaitTime;
+extern	cvar_t	*sv_allowLoadPosition;
+extern	cvar_t	*sv_loadPositionWaitTime;
+
 extern	serverBan_t serverBans[SERVER_MAXBANS];
 extern	int serverBansCount;
 
Index: code/server/sv_init.c
===================================================================
--- code/server/sv_init.c	(revision 815)
+++ code/server/sv_init.c	(working copy)
@@ -544,6 +544,9 @@
 				/////////////////////////////////////////////
 				// separator for mutefix.patch and goto.patch
 				/////////////////////////////////////////////
+				svs.clients[i].positionIsSaved = qfalse;
+				svs.clients[i].lastLoadPositionTime = 0;
+				svs.clients[i].lastGotoTime = 0;
 				if( !isBot ) {
 					// when we get the next packet from a connected client,
 					// the new gamestate will be sent
@@ -691,6 +694,11 @@
 
 	sv_userinfoFloodProtect = Cvar_Get ("sv_userinfoFloodProtect", "1", CVAR_ARCHIVE | CVAR_SERVERINFO );
 
+	sv_allowGoto = Cvar_Get("sv_allowGoto", "0", CVAR_ARCHIVE);
+	sv_gotoWaitTime = Cvar_Get("sv_gotoWaitTime", "180", CVAR_ARCHIVE);
+	sv_allowLoadPosition = Cvar_Get("sv_allowLoadPosition", "0", CVAR_ARCHIVE);
+	sv_loadPositionWaitTime = Cvar_Get("sv_loadPositionWaitTime", "180", CVAR_ARCHIVE);
+
 	// initialize bot cvars so they are listed and can be set before loading the botlib
 	SV_BotInitCvars();
 
Index: code/server/sv_main.c
===================================================================
--- code/server/sv_main.c	(revision 815)
+++ code/server/sv_main.c	(working copy)
@@ -61,6 +61,11 @@
 cvar_t	*sv_userinfoFloodProtect;	// whether to limit two client userinfo changes per 2000 milliseconds,
 					// default 1 (limit)
 
+cvar_t	*sv_allowGoto;
+cvar_t	*sv_gotoWaitTime;
+cvar_t	*sv_allowLoadPosition;
+cvar_t	*sv_loadPositionWaitTime;
+
 serverBan_t serverBans[SERVER_MAXBANS];
 int serverBansCount = 0;
 
