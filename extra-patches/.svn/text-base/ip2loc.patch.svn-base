Index: code/server/sv_client.c
===================================================================
--- code/server/sv_client.c	(revision 927)
+++ code/server/sv_client.c	(working copy)
@@ -316,6 +316,67 @@
 
 /*
 ==================
+SV_ResolveIP2Loc
+
+sv_ip2locHost->string is not touched by this function.  svs.ip2locAddress.type
+will be set to NA_BAD when resolution fails or when sv_ip2locHost is empty.
+==================
+*/
+void SV_ResolveIP2Loc( void ) {
+	int	res;
+
+	if (sv_ip2locHost->modified || // This will be true when server starts up even if sv_playerDBHost is empty.
+			svs.ip2locAddress.type == 0) { // SV_Shutdown(), which gets called after 23 days, zeroes out svs.
+		sv_ip2locHost->modified = qfalse;
+		if (sv_ip2locHost->string[0]) {
+			Com_Printf("Resolving ip2loc server address %s\n", sv_ip2locHost->string);
+			res = NET_StringToAdr(sv_ip2locHost->string, &svs.ip2locAddress, NA_IP); // ip2loc service runs only on IPv4 addresses for now.
+			if (!res) {
+				// svs.ip2locAddress.type will be set to NA_BAD by NET_StringToAdr().
+				Com_Printf("Couldn't resolve ip2loc server address: %s\n", sv_ip2locHost->string);
+				return;
+			}
+			if (res == 2) {
+				// Set the default port since it was not specified.
+				svs.ip2locAddress.port = BigShort(10020);
+			}
+			Com_Printf("%s (ip2loc server) resolved to %s\n", sv_ip2locHost->string,
+					NET_AdrToStringwPort(svs.ip2locAddress));
+		}
+		else {
+			svs.ip2locAddress.type = NA_BAD;
+		}
+	}
+}
+
+/*
+==================
+SV_SendIP2LocPacketConditionally
+
+Will only send a packet to the ip2loc service if sv_ip2locEnable is nonzero positive and
+if svs.ip2locAddress.type is not NA_BAD after a resolution attempt.  If sv_ip2locPassword
+is empty a packet will still be sent.  A packet will not be sent if this is a LAN address.
+==================
+*/
+void SV_SendIP2LocPacketConditionally( client_t *cl ) {
+	netadr_t	adr;
+
+	if (sv_ip2locEnable->integer > 0) {
+		SV_ResolveIP2Loc();
+		adr = cl->netchan.remoteAddress;
+		if (svs.ip2locAddress.type != NA_BAD && !Sys_IsLANAddress(adr)) {
+			int ip2locChallenge = ((rand() << 16) ^ rand()) ^ svs.time;
+			cl->ip2locChallenge = ip2locChallenge;
+			Com_DPrintf("Sending ip2loc packet for client address %s\n", NET_AdrToString(adr));
+			Com_DPrintf("    ...ip2loc server is %s\n", NET_AdrToStringwPort(svs.ip2locAddress));
+			NET_OutOfBandPrint(NS_SERVER, svs.ip2locAddress, "ip2locRequest\n%s\ngetLocationForIP:%08x\n%s\n",
+					sv_ip2locPassword->string, ip2locChallenge, NET_AdrToString(adr));
+		}
+	}
+}
+
+/*
+==================
 SV_DirectConnect
 
 A "connect" OOB command has been received
@@ -582,6 +643,8 @@
 	// gamestate message was not just sent, forcing a retransmit
 	newcl->gamestateMessageNum = -1;
 
+	SV_SendIP2LocPacketConditionally(newcl);
+
 	// if this was the first client on the server, or the last client
 	// the server can hold, send a heartbeat to the master.
 	count = 0;
@@ -1409,6 +1472,9 @@
 	char	*ip;
 	int		i;
 
+	if (!cl->location[0]) {
+		Info_RemoveKey(cl->userinfo, "location");
+	}
 	////////////////////////////////////////////////////
 	// separator for ip2loc.patch and namesanitize.patch
 	////////////////////////////////////////////////////
@@ -1480,6 +1546,14 @@
 		return "Userinfo overflow.";
 	}
 
+	// Don't allow the client to override their location cvar.
+	if (cl->location[0]) {
+		// We've already made sure that the cl->location string does not contain illegal characters.
+		if (Info_SetValueForKeySilent(cl->userinfo, "location", cl->location)) {
+			SV_DropClient(cl, "userinfo string length exceeded");
+			return "Userinfo overflow.";
+		}
+	}
 	////////////////////////////////////////////////
 	// separator for ip2loc.patch and playerdb.patch
 	////////////////////////////////////////////////
Index: code/server/server.h
===================================================================
--- code/server/server.h	(revision 927)
+++ code/server/server.h	(working copy)
@@ -133,6 +133,8 @@
 	struct netchan_buffer_s *next;
 } netchan_buffer_t;
 
+#define	MAX_LOCATION_STRING	96
+
 typedef struct client_s {
 	clientState_t	state;
 	char			userinfo[MAX_INFO_STRING];		// name, etc
@@ -202,6 +204,8 @@
 	///////////////////////////////////////////////
 	// separator for mutefix.patch and ip2loc.patch
 	///////////////////////////////////////////////
+	char				location[MAX_LOCATION_STRING];
+	int				ip2locChallenge;
 	////////////////////////////////////////////
 	// separator for ip2loc.patch and goto.patch
 	////////////////////////////////////////////
@@ -268,6 +272,8 @@
 
 	netadr_t	authorizeAddress;			// for rcon return messages
 
+	netadr_t	ip2locAddress;				// holds resolution of sv_ip2locHost
+
 	////////////////////////////////////////////////
 	// separator for ip2loc.patch and playerdb.patch
 	////////////////////////////////////////////////
@@ -324,6 +330,10 @@
 
 extern	cvar_t	*sv_userinfoFloodProtect;
 
+extern	cvar_t	*sv_ip2locEnable;
+extern	cvar_t	*sv_ip2locHost;
+extern	cvar_t	*sv_ip2locPassword;
+
 extern	serverBan_t serverBans[SERVER_MAXBANS];
 extern	int serverBansCount;
 
Index: code/server/sv_init.c
===================================================================
--- code/server/sv_init.c	(revision 927)
+++ code/server/sv_init.c	(working copy)
@@ -691,6 +691,10 @@
 
 	sv_userinfoFloodProtect = Cvar_Get ("sv_userinfoFloodProtect", "1", CVAR_ARCHIVE | CVAR_SERVERINFO );
 
+	sv_ip2locEnable = Cvar_Get ("sv_ip2locEnable", "0", CVAR_ARCHIVE );
+	sv_ip2locHost = Cvar_Get ("sv_ip2locHost", "", CVAR_ARCHIVE );
+	sv_ip2locPassword = Cvar_Get ("sv_ip2locPassword", "", CVAR_TEMP );
+
 	// initialize bot cvars so they are listed and can be set before loading the botlib
 	SV_BotInitCvars();
 
Index: code/server/sv_main.c
===================================================================
--- code/server/sv_main.c	(revision 927)
+++ code/server/sv_main.c	(working copy)
@@ -61,6 +61,10 @@
 cvar_t	*sv_userinfoFloodProtect;	// whether to limit two client userinfo changes per 2000 milliseconds,
 					// default 1 (limit)
 
+cvar_t	*sv_ip2locEnable;		// whether to enable messages showing where players connect from, default 0, disable
+cvar_t	*sv_ip2locHost;			// host and port of the ip2loc service, e.g. "localhost:10020"
+cvar_t	*sv_ip2locPassword;		// password for the ip2loc service
+
 serverBan_t serverBans[SERVER_MAXBANS];
 int serverBansCount = 0;
 
@@ -616,6 +620,206 @@
 }
 
 /*
+===============
+SVC_HandleIP2Loc
+
+Deal with packets from the ip2loc lookup service.  Packets should be of the form:
+\xFF\xFF\xFF\xFFip2locResponse "getLocationForIP" "<IP address>" "<country code>" "<country>" "<region>" "<city>" "<latitude>" "<longitude>"
+===============
+*/
+void SVC_HandleIP2Loc( netadr_t from ) {
+	char		*arg1;
+	char		*arg2;
+	const	char	*command = "getLocationForIP:xxxxxxxx";
+	int		challenge;
+	char		chalCh;
+	netadr_t	clientadr;
+	int		i;
+	client_t	*cl;
+	qboolean	countryNeedsRegion = qfalse;
+	qboolean	citySpecified = qfalse;
+	qboolean	regionSpecified = qfalse;
+	qboolean	countrySpecified = qfalse;
+	static	qboolean	charMap[256];
+	static	qboolean	charMapInitialized = qfalse;
+	char		*ch;
+
+	if (!(sv_ip2locHost->string[0] && sv_ip2locEnable->integer > 0)) {
+		Com_DPrintf("ip2locResponse packet received from %s unexpectedly\n",
+			NET_AdrToStringwPort(from));
+		return;
+	}
+	// NET_CompareAdr() will compare the .type of the address, which will be NA_BAD for svs.ip2locAddress if resolution failed.
+	if (!NET_CompareAdr(from, svs.ip2locAddress)) {
+		Com_DPrintf("ip2locResponse packet received from invalid ip2loc server: %s\n",
+			NET_AdrToStringwPort(from));
+		return;
+	}
+
+	arg1 = Cmd_Argv(1);
+	if (strlen(command) != strlen(arg1) ||
+			Q_strncmp(command, arg1, 17)) { // Check up to and including the ':'.
+		Com_DPrintf("We only understand \"%s\" on ip2locResponse packets\n", command);
+		return;
+	}
+	challenge = 0;
+	for (i = 0; i < 8; i++) {
+		chalCh = arg1[17 + i];
+		if ('0' <= chalCh && chalCh <= '9') {
+			challenge |= (chalCh - '0') << ((7 - i) << 2);
+		}
+		else if ('a' <= chalCh && chalCh <= 'f') {
+			challenge |= (chalCh - 'a' + 10) << ((7 - i) << 2);
+		}
+		else {
+			Com_DPrintf("Invalid challenge \"%s\" in ip2LocResponse packet\n", arg1 + 17);
+			return;
+		}
+	}
+	Com_DPrintf("SVC_HandleIP2Loc: parsed hex challenge %s to be %i\n", arg1 + 17, challenge);
+
+	arg2 = Cmd_Argv(2);
+	Com_DPrintf("ip2locResponse packet for client address %s\n", arg2);
+	// Make sure this is an IP address (so that DNS lookups won't happen below).
+	if (!NET_IsIP(arg2)) { // Unfortunately does not currently handle IPv6.
+		Com_DPrintf("Invalid IP address in ip2locResponse packet: %s\n", arg2);
+		return;
+	}
+	if (!NET_StringToAdr(arg2, &clientadr, /* NA_UNSPEC */ NA_IP)) { // Should never ever happen.
+		Com_DPrintf("Invalid IP address in ip2locResponse packet: %s\n", arg2);
+		return;
+	}
+
+	if (Sys_IsLANAddress(clientadr)) {
+		Com_DPrintf("Received ip2loc packet for LAN address %s, ignoring\n", NET_AdrToString(clientadr));
+		return;
+	}
+
+	for (i = 0, cl = svs.clients; i < sv_maxclients->integer; i++, cl++) {
+		if (cl->state < CS_CONNECTED || cl->netchan.remoteAddress.type == NA_BOT || cl->location[0] ||
+				challenge != cl->ip2locChallenge) {
+			continue;
+		}
+		if (NET_CompareBaseAdr(clientadr, cl->netchan.remoteAddress)) {
+			if (Cmd_Argv(6)[0]) {
+				Q_strcat(cl->location, sizeof(cl->location), Cmd_Argv(6));
+				citySpecified = qtrue;
+			}
+			if ((!Q_stricmp(Cmd_Argv(3), "US")) || (!Q_stricmp(Cmd_Argv(3), "CA"))) {
+				countryNeedsRegion = qtrue;
+			}
+			if (countryNeedsRegion && Cmd_Argv(5)[0]) {
+				if (citySpecified) {
+					Q_strcat(cl->location, sizeof(cl->location), ", ");
+				}
+				Q_strcat(cl->location, sizeof(cl->location), Cmd_Argv(5));
+				regionSpecified = qtrue;
+			}
+			if (Cmd_Argv(4)[0]) {
+				if (regionSpecified && citySpecified) {
+					Q_strcat(cl->location, sizeof(cl->location), " (");
+				}
+				else if (regionSpecified || citySpecified) {
+					Q_strcat(cl->location, sizeof(cl->location), ", ");
+				}
+				Q_strcat(cl->location, sizeof(cl->location), Cmd_Argv(4));
+				if (regionSpecified && citySpecified) {
+					Q_strcat(cl->location, sizeof(cl->location), ")");
+				}
+				countrySpecified = qtrue;
+			}
+
+			if (citySpecified || regionSpecified || countrySpecified) {
+				// Check the location string.  If the ip2loc server sends malicious strings,
+				// it may force the client to be dropped when we change their userinfo.
+				// Allow the same characters that the checkuserinfo.patch allows.
+				if (!charMapInitialized) {
+					// These are characters that are allowed/disallowed to be in cvar keys and values.
+					for (i = 0;   i <= 31;  i++) { charMap[i] = qfalse; }
+					for (i = 32;  i <= 33;  i++) { charMap[i] = qtrue; }
+					charMap[34] = qfalse; // double quote
+					for (i = 35;  i <= 58;  i++) { charMap[i] = qtrue; }
+					charMap[59] = qfalse; // semicolon
+					for (i = 60;  i <= 91;  i++) { charMap[i] = qtrue; }
+					charMap[92] = qfalse; // backslash
+					for (i = 93;  i <= 126; i++) { charMap[i] = qtrue; }
+					for (i = 127; i <= 255; i++) { charMap[i] = qfalse; }
+					charMapInitialized = qtrue;
+				}
+				ch = cl->location;
+				while (*ch) {
+					if (!charMap[0xff & *ch]) {
+						Com_DPrintf("The ip2loc server is misbehaving; the location for IP %s ended "
+								"up being \"%s\", which contains illegal characters\n",
+								NET_AdrToString(clientadr), cl->location);
+						Q_strncpyz(cl->location, "ILLEGAL CHARACTERS IN LOCATION", sizeof(cl->location));
+						break;
+					}
+					ch++;
+				}
+				
+				if ('\0' == *ch) {
+					// No illegal characters present in location string.
+					SV_SendServerCommand(NULL, "print \"    from %s\n\"", cl->location);
+				}
+			}
+			else {
+				Q_strncpyz(cl->location, "UNKNOWN LOCATION", sizeof(cl->location));
+			}
+			ch = SV_UserinfoChanged(cl);
+			if (ch && ch[0]) { return; }
+			VM_Call(gvm, GAME_CLIENT_USERINFO_CHANGED, cl - svs.clients);
+			return;
+		}
+	}
+}
+
+/*
+================
+SVC_StatuswLoc
+
+Same as SVC_Status() but with [quoted] locations after player names.
+================
+*/
+void SVC_StatuswLoc(netadr_t from) {
+	char		player[1024];
+	char		status[MAX_MSGLEN];
+	int		i;
+	client_t	*cl;
+	playerState_t	*ps;
+	int		statusLength;
+	char		infostring[MAX_INFO_STRING];
+
+	// Ignore if we are in single player.
+	if (Cvar_VariableValue("g_gametype") == GT_SINGLE_PLAYER) {
+		return;
+	}
+
+	Q_strncpyz(infostring, Cvar_InfoString(CVAR_SERVERINFO), sizeof(infostring));
+
+	// Prevent spoofed reply packets.  In case of overflow or illegal characters, it's
+	// OK, we just won't include the challenge in the response.
+	Info_SetValueForKeySilent(infostring, "challenge", Cmd_Argv(1));
+
+	status[0] = '\0'; // In case there are no clients.
+	statusLength = 0;
+
+	for (i = 0; i < sv_maxclients->integer; i++) {
+		if (statusLength >= sizeof(status) - 1) { break; }
+		cl = &svs.clients[i];
+		if (cl->state >= CS_CONNECTED) {
+			ps = SV_GameClientNum(i);
+			Q_snprintf(player, sizeof(player), "%i %i \"%s\" \"%s\"\n",
+					ps->persistant[PERS_SCORE], cl->ping, cl->name, cl->location);
+			Q_strncpyz(status + statusLength, player, sizeof(status) - statusLength);
+			statusLength += strlen(player);
+		}
+	}
+
+	NET_OutOfBandPrint(NS_SERVER, from, "statuswlocResponse\n%s\n%s", infostring, status);
+}
+
+/*
 =================
 SV_ConnectionlessPacket
 
@@ -658,6 +862,11 @@
 #endif
 	} else if (!Q_stricmp(c, "rcon")) {
 		SVC_RemoteCommand( from, msg );
+	} else if (!Q_stricmp(c, "ip2locResponse")) {
+		SVC_HandleIP2Loc( from );
+	} else if (!Q_stricmp(c, "getstatuswloc")) {
+		if (SV_CheckDRDoS(from)) { return; }
+		SVC_StatuswLoc( from );
 	////////////////////////////////////////////////
 	// separator for ip2loc.patch and playerdb.patch
 	////////////////////////////////////////////////
