Index: code/server/sv_client.c
===================================================================
--- code/server/sv_client.c	(revision 822)
+++ code/server/sv_client.c	(working copy)
@@ -435,6 +435,28 @@
 			///////////////////////////////////////////////////////
 			// separator for playerdb.patch and reconnectwait.patch
 			///////////////////////////////////////////////////////
+			int	reconnectWaitTime;
+			if ((reconnectWaitTime = sv_reconnectWaitTime->integer) > 0) {
+				if (reconnectWaitTime > 300) { // 5 minutes.
+					reconnectWaitTime = 300;
+				}
+				reconnectWaitTime *= 1000;
+				drop_t		*drop;
+				drop = &svs.drops[0];
+				for (i = 0; i < MAX_DROPS; i++, drop++) {
+					if (NET_CompareAdr(from, drop->adr)) {
+						int	reconnectAbsoluteTime;
+						reconnectAbsoluteTime = drop->time + drop->waitFactor * reconnectWaitTime;
+						if (reconnectAbsoluteTime > svs.time) {
+							NET_OutOfBandPrint(NS_SERVER, from,
+								"print\nReconnecting, please wait...\n");
+							Com_DPrintf("Client from %s waiting to reconnect\n",
+								NET_AdrToStringwPort(from));
+							return;
+						}
+					}
+				}
+			}
 
 			if ( sv_minPing->value && ping < sv_minPing->value ) {
 				NET_OutOfBandPrint( NS_SERVER, from, "print\nServer is for high pings only\n" );
@@ -660,6 +682,38 @@
 		return;
 	}
 
+	if (drop->netchan.remoteAddress.type != NA_BOT) {
+		drop_t		*dropRecord;
+		int		oldest;
+		int		oldestTime;
+		dropRecord = &svs.drops[0];
+		oldest = 0;
+		oldestTime = 0x7fffffff;
+		for (i = 0; i < MAX_DROPS; i++, dropRecord++) {
+			if (NET_CompareAdr(drop->netchan.remoteAddress, dropRecord->adr)) {
+				// Try to reuse a drop in case they're flooding and the attacker can't figure out
+				// to change the port each time.  (We could really get rid of this actually.)
+				break;
+			}
+			if (dropRecord->time < oldestTime) {
+				oldestTime = dropRecord->time;
+				oldest = i;
+			}
+		}
+		if (i == MAX_DROPS) {
+			dropRecord = &svs.drops[oldest];
+		}
+		dropRecord->adr = drop->netchan.remoteAddress;
+		dropRecord->time = svs.time;
+		dropRecord->waitFactor = 1;
+		if (!strcmp("was kicked", reason)) { // Vote kicked or kicked/banned by admin.
+			dropRecord->waitFactor = 2;
+		}
+		if (!strcmp("Teamkilling is bad m'kay?", reason)) { // Booted for team killing.
+			dropRecord->waitFactor = 3;
+		}
+	}
+
 	// Kill any download
 	SV_CloseDownload( drop );
 
Index: code/server/server.h
===================================================================
--- code/server/server.h	(revision 822)
+++ code/server/server.h	(working copy)
@@ -234,6 +234,14 @@
 // separator for connectlimit.patch and reconnectwait.patch
 ///////////////////////////////////////////////////////////
 
+#define MAX_DROPS	256
+
+typedef struct {
+	netadr_t	adr;
+	int		time;
+	int		waitFactor;
+} drop_t;
+
 #define	MAX_MASTERS	8				// max recipients for heartbeat packets
 
 
@@ -254,6 +262,7 @@
 	///////////////////////////////////////////////////////////
 	// separator for connectlimit.patch and reconnectwait.patch
 	///////////////////////////////////////////////////////////
+	drop_t		drops[MAX_DROPS];
 	netadr_t	redirectAddress;			// for rcon return messages
 
 	netadr_t	authorizeAddress;			// for rcon return messages
@@ -314,6 +323,8 @@
 
 extern	cvar_t	*sv_userinfoFloodProtect;
 
+extern	cvar_t	*sv_reconnectWaitTime;
+
 extern	serverBan_t serverBans[SERVER_MAXBANS];
 extern	int serverBansCount;
 
Index: code/server/sv_init.c
===================================================================
--- code/server/sv_init.c	(revision 822)
+++ code/server/sv_init.c	(working copy)
@@ -691,6 +691,8 @@
 
 	sv_userinfoFloodProtect = Cvar_Get ("sv_userinfoFloodProtect", "1", CVAR_ARCHIVE | CVAR_SERVERINFO );
 
+	sv_reconnectWaitTime = Cvar_Get("sv_reconnectWaitTime", "0", CVAR_ARCHIVE);
+
 	// initialize bot cvars so they are listed and can be set before loading the botlib
 	SV_BotInitCvars();
 
Index: code/server/sv_main.c
===================================================================
--- code/server/sv_main.c	(revision 822)
+++ code/server/sv_main.c	(working copy)
@@ -61,6 +61,8 @@
 cvar_t	*sv_userinfoFloodProtect;	// whether to limit two client userinfo changes per 2000 milliseconds,
 					// default 1 (limit)
 
+cvar_t	*sv_reconnectWaitTime;
+
 serverBan_t serverBans[SERVER_MAXBANS];
 int serverBansCount = 0;
 
